using System;
using System.Threading;

namespace ConsoleApp10
{
    // Вынесение интерфейсов в отдельное пространство имен
    public interface ILogger
    {
        void Event(string message);
        void Error(string message);
    }

    public interface IWorker
    {
        void Work();
    }

    class Program
    {
        static void Main(string[] args)
        {
            //Модуль 10. Интерфейсы
            //10.1. Интерфейсы
            /* 
            В предыдущих модулях мы рассматривали абстрактные классы.Надеюсь, вы не забыли, что это такое.Я это спрашиваю потому, что интерфейсы имеют сходство 
            с абстрактными классами, и знание определения абстрактного класса нам необходимо.

            Задание 10.1.1 Что такое абстрактный класс?

                Класс, экземпляр которого нельзя создать    X
                Класс, который нельзя наследовать
                Класс, который не содержит конструктора

            Ответ - Экземпляр абстрактного класса, так же как и интерфейса, создать нельзя.

            Что же такое интерфейс? 

            Официальное определение от MSDN гласит, что интерфейс определяет контракт.  А контракт — это соглашение между сторонами.

                Другими словами, интерфейс определяет функциональные возможности производного класса.

            Интерфейс говорит производному классу: «Ты обязан делать это и это... иначе никак!».

            Давайте сразу рассмотрим, как определить интерфейс в приложении. Для этого пишем следующий код:

                public interface IWriter 
                {
                  void Write();
                 }

            Как мы видим, наш интерфейс называется IWriter, он содержит в себе определение функции Write. Любой класс, который будет определять интерфейс IWriter, 
            обязан содержать в себе функцию Write.

                Важно запомнить! По всем законам синтаксиса в программировании интерфейсам принято задавать имя с заглавной буквы I (ай), а затем само название интерфейса.

            Выберите несколько интерфейсов из списка, у которых синтаксически корректное название:

                1. _IReader
                2. ILogger  X
                3. iLogger
                4. IReader  X

                2. Интерфейсам принято задавать имя с заглавной буквы I (ай), а затем само название интерфейса.
                4. Интерфейсам принято задавать имя с заглавной буквы I (ай), а затем само название интерфейса.

            Интерфейсы очень похожи на абстрактные классы и заполучили от них важную особенность: экземпляр интерфейса нельзя создать, точно так же, как и экземпляр абстрактного класса. 

            Для демонстрации данной особенности воспользуемся нашим интерфейсом IWriter.

            Мы никогда не сможем создать экземпляр вот так: при этом компилятор выдаст ошибку, т.к. нет реализации метода IWrieter.Write()

                public interface IWriter
                {
                     void Write();
                }

                public class Writer : IWriter
                {

                }


            Производный класс Writer применяет интерфейс IWriter, тем самым соглашаясь на условия интерфейса IWriter и подписывая с ним контракт.

            Интерфейс IWriter определяет в контракте обязательную реализацию метода Write(). Поэтому и производный класс Writer обязан реализовать этот метод, 
            обязан соблюдать условия контракта... иначе приложение не скомпилируется.

            Начиная с версии языка C# 8.0 появилась ещё одна особенность интерфейсов: интерфейсы теперь могут содержать в своих методах и свойствах реализацию 
            по умолчанию. Это не может не радовать. 

            В более ранних версиях (<8.0) реализация по умолчанию не поддерживалась и, например, сделать вот так не получалось:

                    public interface IWriter
                    {
                        void Write() { Console.WriteLine("I am a Writer"); }
                    }

                    public class Writer : IWriter
                   {

                   }

            Но 23 сентября 2019 года вышла в релиз восьмая версия C#, в которой мы можем делать реализацию по умолчанию в интерфейсах без каких-либо ошибок компилятора:

            Если у вас рабочая версия ниже 8 и вы планируете перебираться на обновлённый .NET, то для перехода можете воспользоваться следующей информационной таблицей:

            Таблица соответствия версий C# и .NET

                Версия C#	.NET Версия	Год
                        C# 12	.NET 8	2023
                        C# 11	.NET 7	2022
                        C# 10	.NET 6	2021
                        C# 9	.NET 5	2020
                        C# 8	.NET Core 3.x	2019
                        C# 7.3	.NET Framework 4.8	2019

            --------------------------------------------------------------------------------------------------------------------
            Console.WriteLine($"Runtime: {Environment.Version}");
            Console.WriteLine($"Framework: {System.Runtime.InteropServices.RuntimeInformation.FrameworkDescription}");

            //Runtime: 4.0.30319.42000
            //Framework: .NET Framework 4.8.9290.0
            --------------------------------------------------------------------------------------------------------------------

            В начале юнита я уже отметил, что интерфейсы имеют сходство с абстрактными классами. При разработке приложений важно знать, когда использовать абстрактный класс, 
            а когда — интерфейс. Не смотря на то, что абстрактные классы и интерфейсы кажутся в некотором роде похожими, существуют ключевые различия, которые определяют,
            какой из них лучше всего подходит для того, какой результат вы желаете получить. 

            Абстрактный класс задаёт иерархию наследования. Тем самым, он создает функциональные возможности для производных классов.

            Интерфейс же описывает только действия. Он позволяет определить только функциональность. И хотя класс может расширять только один абстрактный класс, 
            интерфейсов он может использовать несколько.


            Тут хочу сразу привести пример про расширение классов и множественное наследование, которого в C# нет. Например, мы можем спокойно определить множество интерфейсов:
                public interface iILogger
                 {
                     void logger() { Console.WriteLine("I am a logger); }
                }


                 public interface IWriter
                    {
                        void Write() { Console.WriteLine("I am a Writer"); }
                    }

                 public class Writer : IWriter, 
                 {

                 }

            В коде выше класс BusinessLogic успешно определяет два интерфейса: ILogger и IWriter. То же самое провернуть с абстрактными классами не получится:

            И это один плюс к интерфейсам. А теперь предлагаю сравнить интерфейс с абстрактным классам в более удобном виде.

                    Да начнётся битва интерфейса против абстрактного класса!

                    1	Абстрактный класс является классом, который нельзя создать.	                                    Интерфейс аналогично тоже нельзя создать.	                    Ничья
                    2	Абстрактный класс может иметь реализацию по умолчанию.	                                        Интерфейс умеет то же самое, начиная с 8-ой версии C#.	        Ничья
                    3	Нельзя наследовать более одного абстрактного класса.	                                        Можно наследовать множество интерфейсов.	                    1 балл интерфейсам
                    4	Члены абстрактного класса могут иметь модификаторы доступа private, public, protected и т.д.	Начиная с 8-ой версии C#, интерфейсы умеют делать то же самое.	Ничья
                    5 	Абстрактные классы могут содержать статические члены	Начиная с 8-ой версии C#.                интерфейсы умеют делать то же самое.	                        Ничья

                                    1:0 в пользу интерфейсов

            Хотя на самом деле тут не всё так однозначно. Результат вовсе не означает, что необходимо забыть про абстрактные классы и везде поголовно юзать интерфейсы. Применение абстрактного класса или интерфейса зависит от необходимой задачи.

            Ещё один немаловажный плюс: интерфейсы используются в Dependency Injection подходе, с которым мы ознакомимся в скринкасте.
            Смотри код проекта

            Когда лучше использовать абстрактные классы?

            Выгодно использовать их, когда вы уверены в необходимости общей реализации. Когда бизнес логика в одном классе обязательно должна присутствовать 
            и в производном без какого-либо копипаста кода благодаря абстрактным классам и наследованию в ООП.

            Когда лучше использовать интерфейсы?

            Когда вы точно знаете, что общая реализация не нужна. Когда вы уверены в том, что не понадобится повторять код в производных классах. Интерфейсы 
            в данном случае отлично подойдут для завязывания контрактов между классами, тем самым диктуя производным классам выполнять бизнес-логику ваших контрактов.
            При этом у вас ещё остаётся место для наследования от другого класса. 

            Задание 10.1.3
            Укажите пропущенное слово в коде:

                public interface IMessenger 
                {
                    void SendMessage();
                }

                public class Messenger: IMessenger 
                {
                    public void _пропущенное_слово_() { }
                }

               Ответ: SendMessage

            Класс Manager реализует интерфейс IManager. Попытайтесь самостоятельно определить интерфейс IManager, исходя из данного кода. 

            public class Manager : IManager
                {
                    public void Create()
                    {

                    }

                     public void Read()
                    {

                    }

                    public void Update()
                     {

                     }

                    public void Delete()
                     {

                     }
                }

            Ответ:

                public interface IManager 
                {
                    void Create();
                    void Read();
                    void Update();
                     void Delete();
                }

            Задание 10.1.5
            Выберите, какие из перечисленных особенностей относятся к интерфейсам:

                1. Один класс может определять неограниченное количество интерфейсов
                2. При определении интерфейса классу не обязательно наследовать все методы и функции в интерфейсе
                3. Интерфейс организует контракт
                4. При наследовании интерфейса нельзя использовать больше одного экземпляра

            Ответ:

            1. Одна из особенностей интерфейсов — это поддержка множественной реализации.
            3. Это одна из особенностей интерфейсов.
            */

            // Использование внедрения зависимостей
            ILogger logger = new Logger();

            // Создание рабочих с общим логгером
            IWorker[] workers = {
                new Worker1(logger),
                new Worker2(logger),
                new Worker3(logger)
            };

            // Запуск всех рабочих
            foreach (var worker in workers)
            {
                worker.Work();
            }

            Console.ReadKey();
        }
    }

    // Реализация логгера
    public class Logger : ILogger
    {
        public void Error(string message)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine($"[ERROR] {DateTime.Now:HH:mm:ss}: {message}");
            Console.ResetColor();
        }

        public void Event(string message)
        {
            Console.ForegroundColor = ConsoleColor.Blue;
            Console.WriteLine($"[EVENT] {DateTime.Now:HH:mm:ss}: {message}");
            Console.ResetColor();
        }
    }

    // Базовый класс для рабочих
    public abstract class WorkerBase : IWorker
    {
        protected ILogger Logger { get; }
        public string Name { get; }

        protected WorkerBase(ILogger logger, string name)
        {
            Logger = logger;
            Name = name;
        }

        public abstract void Work();

        protected void LogEvent(string action)
        {
            Logger.Event($"{Name} {action}");
        }
    }

    // Конкретные реализации рабочих
    public class Worker1 : WorkerBase
    {
        public Worker1(ILogger logger) : base(logger, "Worker1") { }

        public override void Work()
        {
            LogEvent("начал свою работу");
            Thread.Sleep(3000);
            LogEvent("закончил свою работу");
        }
    }

    public class Worker2 : WorkerBase
    {
        public Worker2(ILogger logger) : base(logger, "Worker2") { }

        public override void Work()
        {
            LogEvent("начал свою работу");
            Thread.Sleep(3000);
            LogEvent("закончил свою работу");
        }
    }

    public class Worker3 : WorkerBase
    {
        public Worker3(ILogger logger) : base(logger, "Worker3") { }

        public override void Work()
        {
            LogEvent("начал свою работу");
            Thread.Sleep(3000);
            LogEvent("закончил свою работу");
        }
    }
}